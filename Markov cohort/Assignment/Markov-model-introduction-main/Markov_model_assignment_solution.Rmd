---
title: "Markov_model_realworld_explain"
author: "Kyu Lee"
date: "2024-01-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## In this document, I provided the solution for HEOR 532 class assignment using 'Markov_model_realworld.R' by Briggs et al

## Description of the assignment ##
A new end-of-life care was approved based on the clinical trial result that it can reduce the excess mortality due to progressive disease by 50%. It costs $X as one-time cost. 

Decision makers (e.g. clinicians) requested information on whether they should provide this end-of-life care in addition to the original treatment approved to reduce the disease progression.

Using the same health state transition model covered in the class, conduct a cost-effectiveness analysis considering three strategies: 1) without treatment 2) with treatment but no end-of-life care, 3) with both treatment and end-of-life care

Provide a table of cost and QALY of three strategies and report ICER

### Basecase analysis ###
1. Define parameters
For this problem, you have three strategies to consider (no treatment no care, treatment no care, treatment and care). You have two additional parameters to define: 1) cCare 2) effect_care 
```{r}
t_names <- c("without_drug", "with_drug", "with_drug_care")#t_names : strategy/scenario label
n_treatments <- length(t_names)#n_treatment: number of strategies

s_names  <- c("Asymptomatic_disease", "Progressive_disease", "Dead")#s_names: vector of health states
n_states <- length(s_names)#n_states: number of health states

n_cohort <- 1000#n_cohort: cohort size
cycle <- 1#cycle: cycle length
n_cycles <- 46#n_cylces: total number of cycles 

Initial_age <- 55#Initial_age: age at the beginning of simulation

cAsymp <- 500#cAsymp: cost of having asymptomatic disease (per-cycle cost)
cDeath <- 1000#cDeath: cost of death (per-cycle cost), only applies to the death among progressive dx
cDrug <- 1000#cDrug: cost of drug  
cProg <- 3000#cProg: cost of having progressive disease (per-cycle cost) 
cCare <- 500 #cCare: cost of end-of-life care 

uAsymp <- 0.95#uAsymp: utility of having asymptomatic disease
uProg <- 0.75#uProg: utility of having progressive disease

oDr <- 0.06#oDr: discount rate for qaly 
cDr <- 0.06#cDr: discount rate for cost

tpDcm <- 0.15#tpDcm: excess mortality with progressive disease 
tpProg <- 0.01#tpProg: transition probability from asymptomatic to progressive disease
tpDn <- 0.0379  #pDn: baseline mortality <- mortality 0.0379  # over 65 year old

effect <- 0.5#effect: drug efficacy in decreasing the risk of progressing from asymptomatic to progressive disease
effect_care <- 0.5 # end-of-care efficacy in decreasing the excess mortality

```


2. Prepare cost, qaly, and transitional cost matrix
Update the payoff/reward matrices to indicate state-specific reward for each of three strategies
```{r}
# cost of staying in state
state_c_matrix <-
  matrix(c(cAsymp, cProg, 0,
           cAsymp + cDrug, cProg, 0,
           cAsymp + cDrug + cCare, cProg, 0),
         byrow = TRUE,
         nrow = n_treatments,
         dimnames = list(t_names,
                         s_names))
state_c_matrix
# qaly when staying in state
state_q_matrix <-
  matrix(c(uAsymp, uProg, 0,
           uAsymp, uProg, 0,
           uAsymp, uProg, 0),
         byrow = TRUE,
         nrow = n_treatments,
         dimnames = list(t_names,
                         s_names))
state_q_matrix
# cost of moving to a state
# same for both treatments
trans_c_matrix <-
  matrix(c(0, 0, 0,
           0, 0, cDeath,
           0, 0, 0),
         byrow = TRUE,
         nrow = n_states,
         dimnames = list(from = s_names,
                         to = s_names))
trans_c_matrix
```


3. Prepare transition probability matrix 
A strategy with end-of-life care will have reduced disease-specific mortality(tpDcm)
```{r}
# Transition probabilities ---- 

# time-homogeneous
p_matrix <- array(data = c(1 - tpProg - tpDn, 0, 0,
                           tpProg, 1 - tpDcm - tpDn, 0,
                           tpDn, tpDcm + tpDn, 1,
                           1 - tpProg*(1-effect) - tpDn, 0, 0,
                           tpProg*(1-effect), 1 - tpDcm - tpDn, 0,
                           tpDn, tpDcm + tpDn, 1,
                           1 - tpProg*(1-effect) - tpDn, 0, 0,
                           tpProg*(1-effect), 1 - tpDcm*(1-effect_care) - tpDn, 0,
                           tpDn, tpDcm*(1-effect_care) + tpDn, 1),
                  dim = c(n_states, n_states, n_treatments),
                  dimnames = list(from = s_names,
                                  to = s_names,
                                  t_names))
p_matrix
```

4. Prepare population matrix that keeps track of health state transition by cycle 
```{r}
# Store population output for each cycle 

# state populations
pop <- array(data = NA,
             dim = c(n_states, n_cycles, n_treatments),
             dimnames = list(state = s_names,
                             cycle = NULL,
                             treatment = t_names))

pop["Asymptomatic_disease", cycle = 1, ] <- n_cohort
pop["Progressive_disease", cycle = 1, ] <- 0
pop["Dead", cycle = 1, ] <- 0

head(pop)
```


5. Prepare a matrix ('trans') to record total transitional cost per cycle by state
```{r}
# _arrived_ state populations
trans <- array(data = NA,
               dim = c(n_states, n_cycles, n_treatments),
               dimnames = list(state = s_names,
                               cycle = NULL,
                               treatment = t_names))

trans[, cycle = 1, ] <- 0
```

6. Prepare empty matrices to record QALYs and Costs outcomes by cycle and by strategy
total_costs and total_QALYs have three empty data entries to match with the number of strategies
```{r}
# Sum costs and QALYs for each cycle at a time for each drug 
cycle_empty_array <-
  array(NA,
        dim = c(n_treatments, n_cycles),
        dimnames = list(treatment = t_names,
                        cycle = NULL)) # per-cycle outcome template matrix

cycle_empty_array

cycle_state_costs <- cycle_trans_costs <- cycle_empty_array
cycle_costs <- cycle_QALYs <- cycle_empty_array
LE <- LYs <- cycle_empty_array    # life expectancy; life-years
cycle_QALE <- cycle_empty_array   # quality-adjusted life expectancy

total_costs <- setNames(c(NA, NA, NA), t_names)
total_QALYs <- setNames(c(NA, NA, NA), t_names)

total_costs
```


7. Define a function to calculate time-dependent transition probability based on age-specific mortality
Because non-mortality transition probabilities can change based on mortality, if mortality is age-dependent (or time-dependent), then other probabilities will be time-dependent as well

```{r}

# Time-dependent probability matrix ----

p_matrix_cycle <- function(p_matrix, age, cycle,
                           tpProg = 0.01,
                           tpDcm = 0.15,
                           effect = 0.5,
                           effect_care = 0.5) {
  tpDn_lookup <-
    c("(34,44]" = 0.0017,
      "(44,54]" = 0.0044,
      "(54,64]" = 0.0138,
      "(64,74]" = 0.0379,
      "(74,84]" = 0.0912,
      "(84,100]" = 0.1958)
  
  age_grp <- cut(age, breaks = c(34,44,54,64,74,84,100)) # find the age group that this age falls into
  tpDn <- tpDn_lookup[age_grp]
  
  # Matrix containing transition probabilities for without_drug
  p_matrix["Asymptomatic_disease", "Progressive_disease", "without_drug"] <- tpProg*cycle
  p_matrix["Asymptomatic_disease", "Dead", "without_drug"] <- tpDn
  p_matrix["Asymptomatic_disease", "Asymptomatic_disease", "without_drug"] <- 1 - tpProg*cycle - tpDn
  p_matrix["Progressive_disease", "Dead", "without_drug"] <- tpDcm + tpDn
  p_matrix["Progressive_disease", "Progressive_disease", "without_drug"] <- 1 - tpDcm - tpDn
  p_matrix["Dead", "Dead", "without_drug"] <- 1
  
  # Matrix containing transition probabilities for with_drug
  p_matrix["Asymptomatic_disease", "Progressive_disease", "with_drug"] <- tpProg*(1 - effect)*cycle
  p_matrix["Asymptomatic_disease", "Dead", "with_drug"] <- tpDn
  p_matrix["Asymptomatic_disease", "Asymptomatic_disease", "with_drug"] <-
    1 - tpProg*(1 - effect)*cycle - tpDn
  p_matrix["Progressive_disease", "Dead", "with_drug"] <- tpDcm + tpDn
  p_matrix["Progressive_disease", "Progressive_disease", "with_drug"] <- 1 - tpDcm - tpDn
  p_matrix["Dead", "Dead", "with_drug"] <- 1
  
  # Matrix containing transition probabilities for with_drug_care
  p_matrix["Asymptomatic_disease", "Progressive_disease", "with_drug_care"] <- tpProg*(1 - effect)*cycle
  p_matrix["Asymptomatic_disease", "Dead", "with_drug_care"] <- tpDn
  p_matrix["Asymptomatic_disease", "Asymptomatic_disease", "with_drug_care"] <-
    1 - tpProg*(1 - effect)*cycle - tpDn
  p_matrix["Progressive_disease", "Dead", "with_drug_care"] <- tpDcm*(1 - effect_care) + tpDn
  p_matrix["Progressive_disease", "Progressive_disease", "with_drug_care"] <- 1 - tpDcm*(1 - effect_care) - tpDn
  p_matrix["Dead", "Dead", "with_drug_care"] <- 1
    
  return(p_matrix)
}
```


8. Simulate a cohort for 'no drug' and 'drug' scenario
```{r}
## Run model ----

for (i in 1:n_treatments) { # outer loop: over strategies
  
  age <- Initial_age
  
  for (j in 2:n_cycles) { # inner loop: over cycles
    # update cycle and age specific transition probability matrix
    p_matrix <- p_matrix_cycle(p_matrix, age, j - 1)
    #print(p_matrix[,,'with_drug']) # Uncomment this line to compare transition probability matrix in two strategies with drugs
    #print(p_matrix[,,'with_drug_care']) 
    # calculate population health state distribution in the next cycle
    pop[, cycle = j, treatment = i] <-
      pop[, cycle = j - 1, treatment = i] %*% p_matrix[, , treatment = i]
    # calculate the total transitional costs per cycle
    trans[, cycle = j, treatment = i] <-
      pop[, cycle = j - 1, treatment = i] %*% (trans_c_matrix * p_matrix[, , treatment = i])
    
    age <- age + 1
  }
  # calculate cycle-specific state costs given a treatment strategy
  cycle_state_costs[i, ] <-
    (state_c_matrix[treatment = i, ] %*% pop[, , treatment = i]) * 1/(1 + cDr)^(1:n_cycles - 1)
  
  # discounting at _previous_ cycle
  cycle_trans_costs[i, ] <-
    (c(1,1,1) %*% trans[, , treatment = i]) * 1/(1 + cDr)^(1:n_cycles - 2) # dot product with c(1,1,1) sums transitional cost across states and generate per-cycle total transitional cost
  # per-cycle cost is the summ of state cost and transitional cost
  cycle_costs[i, ] <- cycle_state_costs[i, ] + cycle_trans_costs[i, ]
  
  # life expectancy
  LE[i, ] <- c(1,1,0) %*% pop[, , treatment = i]
  
  # life-years
  LYs[i, ] <- LE[i, ] * 1/(1 + oDr)^(1:n_cycles - 1)
  
  # quality-adjusted life expectancy
  cycle_QALE[i, ] <-
    state_q_matrix[treatment = i, ] %*% pop[, , treatment = i]
  
  # quality-adjusted life-years
  cycle_QALYs[i, ] <- cycle_QALE[i, ] * 1/(1 + oDr)^(1:n_cycles - 1)
  # calculate the total cost and qaly (sum of per-cycle costs and qalys) of each scenario
  total_costs[i] <- sum(cycle_costs[treatment = i, -1])
  total_QALYs[i] <- sum(cycle_QALYs[treatment = i, -1])
}
```


9. Check the total cost and qaly by strategy and calculate incremental cost and qaly between two strategies
Three strategies are in the increasing order in both cost and qaly. Hence, no strategy is strongly dominated.

```{r}
total_costs
total_QALYs
# Incremental costs and QALYs of with_drug vs without_drug
c_incr1 <- total_costs["with_drug"] - total_costs["without_drug"]
q_incr1 <- total_QALYs["with_drug"] - total_QALYs["without_drug"]
# Incremental costs and QALYs of with_drug_care vs with_drug
c_incr2 <- total_costs["with_drug_care"] - total_costs["with_drug"]
q_incr2 <- total_QALYs["with_drug_care"] - total_QALYs["with_drug"]
```

10. Calculate ICER
```{r}
# Incremental cost-effectiveness ratio
ICER1 <- c_incr1/q_incr1
ICER2 <- c_incr2/q_incr2

print(ICER1);print(ICER2)
```

11. Plot
Here I provided an example code to plot using ggplot function instead of plot
```{r}
# First, install and load ggplot2 package
if(!'ggplot2' %in% installed.packages()){install.packages('ggplot2')}
library(ggplot2)

# To use ggplot, create a dataframe that have both outcomes in one table
dt_ICER <- data.frame(strategy = t_names,
                   q_incr = c(0,q_incr1,q_incr2),
                   c_incr = c(0,c_incr1,c_incr2))

wtp <- 20000
ggplot(dt_ICER,aes(x=q_incr,y=c_incr,label=strategy))+
  geom_point()+
  geom_abline(aes(intercept=0,slope=wtp))+
  geom_text(hjust=0.5,vjust=1)+
  xlab("QALY difference")+
  ylab("Cost difference")+
  theme_bw()
ggsave("figures/ceplane_point_assignment.png", width = 4, height = 4, units = "in")

```

